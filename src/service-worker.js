/* eslint-disable no-restricted-globals */

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.




import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate } from 'workbox-strategies';
import { get, set } from './Helpers/utils';

clientsClaim();
const CACHE_VERSION = 'v13'

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
precacheAndRoute(self.__WB_MANIFEST);

registerRoute(
    ({ request, url }) => {
        // Exclude API calls
        // if (url.pathname.includes('DataService')) {
        //     return false;
        // }

        // Cache based on file extension
        const [file, extension] = url.pathname.split('.');
        if (extension) {
            const staticFileExtensions = [
                'css', 'js', 'json', 'png', 'jpg', 'jpeg',
                'svg', 'gif', 'woff', 'woff2', 'ttf', 'eot'
            ];
            if (staticFileExtensions.includes(extension.toLowerCase()) &&
                !file.toLowerCase().includes('service-worker')) {
                return true;
            }
        }

        // Cache based on request destination
        return ['style', 'script', 'font', 'image']
            .includes(request.destination);
    },
    new StaleWhileRevalidate({
        cacheName: 'static-resources',
        plugins: [
            new ExpirationPlugin({
                maxEntries: 100,
                maxAgeSeconds: 24 * 60 * 60, // 24 hours
            }),
        ],
    })
);




//The below section handles the issue of refreshing the application when a new version is available.

// The register call always triggers the browser to check the server 
// for updates to the service-worker.js file. If the server detects
// a new version, it will be installed and but not activated.
// skipWaiting() forces the new SW to activate immediately, :
// Immediate control
// No waiting for old SW to die
self.addEventListener('install', event => {
    self.skipWaiting();
});
//forces the new active SW to take control of all existing tabs immediately, instead of waiting for a tab reload.
self.addEventListener('activate', event => {
    event.waitUntil(self.clients.claim());
});

//////////////////////////

self.addEventListener('push', function (event) {
    console.log('Push message received', event);
    if (event.data) {
        const data = event.data.json();
        console.log('Push data:', data);

        event.waitUntil(
            get('notifications')
                .then(existingNotifications => {
                    const notifications = existingNotifications || [];

                    // Add new notification with timestamp
                    const newNotification = {
                        ...data,
                        data: {
                            ...data.data,
                            timestamp: Date.now()
                        },
                        read: false
                    };

                    // Append new notification
                    const updatedNotifications = [...notifications, newNotification];

                    // Sort by timestamp
                    updatedNotifications.sort((a, b) => {
                        const timeA = a.data?.timestamp || 0;
                        const timeB = b.data?.timestamp || 0;
                        return timeB - timeA;
                    });

                    // Save updated notifications
                    return set('notifications', updatedNotifications)
                        .then(() => {
                            // Notify all clients about the new notification
                            return self.clients.matchAll({ includeUncontrolled: true, type: 'window' })
                                .then(clients => {
                                    clients.forEach(client => {
                                        client.postMessage({
                                            type: 'NOTIFICATION_COUNT_UPDATE',
                                            notifications: updatedNotifications,
                                            count: updatedNotifications.filter(n => !n.read).length
                                        });
                                    });
                                });
                        });
                })
        );

        const options = {
            body: data.body,
            icon: '/icon512_maskable.png',  // Main app icon
            badge: '/icon512_maskable.png', // Small icon shown in notification area
            image: data.image, // Optional large image for the notification
            vibrate: [100, 50, 100],
            data: {
                ...data.data,
                timestamp: Date.now()
            },
            actions: [
                {
                    action: 'open',
                    title: 'Open'
                },
                {
                    action: 'close',
                    title: 'Close'
                }
            ]
        };

        event.waitUntil(
            self.registration.showNotification(data.title, options)
        );
    }
});

self.addEventListener('notificationclick', event => {
    let notif = event.notification;
    let action = event.action;

    // Close the notification
    notif.close();

    // Handle different actions
    if (action === 'open') {
        event.waitUntil(
            self.clients.matchAll({ includeUncontrolled: true, type: 'window' }).then(clientList => {
                //put the delay on purpose, to allow the application to open the window
                //otherwise event will not be intercepted
                setTimeout(() => {
                    clientList.forEach(client => {
                        client.postMessage({
                            type: 'NOTIFICATION_OPEN',
                            notification: {
                                title: notif.title,
                            },
                        });
                    });
                }, 2000);

                // If a window tab is already open, focus it
                for (const client of clientList) {
                    if ('focus' in client) {
                        return client.focus();
                    }
                }
                // If no window tab is open, open a new one
                if (self.clients.openWindow) {
                    return self.clients.openWindow('/PrivilegeCard');
                }



            })
        );


    } else if (action === 'close') {
        // Handle close action
        console.log('Notification closed by user');

    } else {
        // Default action (clicking the notification body)
        event.waitUntil(
            self.clients.matchAll({ includeUncontrolled: true, type: 'window' }).then(clientList => {
                // If a window tab is already open, focus it
                for (const client of clientList) {
                    if ('focus' in client) {
                        return client.focus();
                    }
                }
                // If no window tab is open, open a new one
                if (self.clients.openWindow) {
                    return self.clients.openWindow('/PrivilegeCard');
                }
            })
        );
    }

    // If you want to clear all notifications of the same tag
    if (notif.tag) {
        self.registration.getNotifications({ tag: notif.tag })
            .then(notifications => {
                notifications.forEach(notification => notification.close());
            });
    }
});

self.addEventListener('notificationclose', event => {
    console.log('Notification was closed')

})


// Any other custom service worker logic can go here.

// Update message handler to use storage helpers
self.addEventListener('message', event => {
    if (event.data.type === 'GET_NOTIFICATIONS') {
        event.waitUntil(
            get('notifications')
                .then(notifications => {
                    event.source.postMessage({
                        type: 'NOTIFICATIONS_DATA',
                        notifications: notifications || []
                    });
                })
        );
    }
    else if (event.data.type === 'CLEAR_NOTIFICATIONS') {
        event.waitUntil(
            set('notifications', [])
        );
    }
    else if (event.data.type === 'MARK_NOTIFICATIONS_READ') {
        event.waitUntil(
            get('notifications')
                .then(notifications => {
                    if (!notifications) return;

                    const updatedNotifications = notifications.map(notification => ({
                        ...notification,
                        read: true
                    }));

                    return set('notifications', updatedNotifications)
                        .then(() => {
                            // Notify all clients about the update
                            return self.clients.matchAll({ includeUncontrolled: true, type: 'window' })
                                .then(clients => {
                                    clients.forEach(client => {
                                        client.postMessage({
                                            type: 'NOTIFICATION_COUNT_UPDATE',
                                            notifications: updatedNotifications,
                                            count: 0 // All notifications are now read
                                        });
                                    });
                                });
                        });
                })
        );
    }
});
