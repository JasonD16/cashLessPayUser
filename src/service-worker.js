/* eslint-disable no-restricted-globals */

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.




import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate } from 'workbox-strategies';

clientsClaim();
const CACHE_VERSION = 'v1';

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
precacheAndRoute(self.__WB_MANIFEST);

// Cache all static assets except API calls
registerRoute(
    ({ request, url }) => {
        // Exclude API calls
        if (url.pathname.includes('HISService') || url.pathname.includes('Admission') || url.pathname.includes('Auth') || url.pathname.includes('Service')) {
            return false;
        }

        // Cache based on file extension
        const fileExtension = url.pathname.split('.').pop();
        if (fileExtension) {
            const staticFileExtensions = [
                'css', 'js', 'json', 'png', 'jpg', 'jpeg',
                'svg', 'gif', 'woff', 'woff2', 'ttf', 'eot'
            ];
            if (staticFileExtensions.includes(fileExtension.toLowerCase())) {
                return true;
            }
        }

        // Cache based on request destination
        return ['style', 'script', 'font', 'image']
            .includes(request.destination);
    },
    new StaleWhileRevalidate({
        cacheName: 'static-resources',
        plugins: [
            new ExpirationPlugin({
                maxEntries: 100,
                maxAgeSeconds: 24 * 60 * 60, // 24 hours
            }),
        ],
    })
);

// Set up App Shell-style routing, so that all navigation requests
// are fulfilled with your index.html shell. Learn more at
// https://developers.google.com/web/fundamentals/architecture/app-shell
const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$');
registerRoute(
    // Return false to exempt requests from being fulfilled by index.html.
    ({ request, url }) => {
        // If this isn't a navigation, skip.
        if (request.mode !== 'navigate') {
            return false;
        } // If this is a URL that starts with /_, skip.

        if (url.pathname.startsWith('/_')) {
            return false;
        } // If this looks like a URL for a resource, because it contains // a file extension, skip.

        if (url.pathname.match(fileExtensionRegexp)) {
            return false;
        } // Return true to signal that we want to use the handler.

        return true;
    },
    createHandlerBoundToURL(process.env.PUBLIC_URL + '/index.html')
);



// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener('message', (event) => {
    if (event.data && event.data.type === 'SKIP_WAITING') {
        self.skipWaiting();
    }
});

self.addEventListener('push', function (event) {
    console.log('received push notification', event.data)
    var data = { title: 'New!', content: 'Some Content' }
    if (event.data) {
        data = JSON.parse(event.data.text())
    }
    var options = {
        body: data.content,
        icon: '/CTS_Logo_Icon.png',
        badge: '/CTS_Logo_Icon.png'

    }
    console.log('Displaying notifsss', data)
    event.waitUntil(
        self.registration.showNotification(data.title, options)
    )
})

self.addEventListener('notificationclick', event => {
    let notif = event.notification;
    let action = event.action;

    if (action === 'hello') {
        console.log('Hello button was clickedddddddd')
    }
    else if (action === 'bye') {
        console.log('GoodBye button was clicked')
    }
    else {
        console.log('Main Notification was clicked')
    }

    notif.close();
})

self.addEventListener('notificationclose', event => {
    console.log('Notification was closed')

})

self.addEventListener('activate', (event) => {
    event.waitUntil(
        Promise.all([
            // Clean up old caches
            caches.keys().then(cacheNames => {
                return Promise.all(
                    cacheNames.map(cacheName => {
                        if (cacheName !== CACHE_VERSION) {
                            return caches.delete(cacheName);
                        }
                    })
                );
            }),
            // Force reload all tabs
            self.clients.claim().then(() => {
                // Optional: Force reload all tabs
                self.clients.matchAll().then(clients => {
                    clients.forEach(client => client.navigate(client.url));
                });
            })
        ])
    );
});

// Any other custom service worker logic can go here.
