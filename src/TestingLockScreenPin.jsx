import React, { useState } from "react";

const TestingLockScreenPin = () => {
  const [authStatus, setAuthStatus] = useState("idle");
  const [error, setError] = useState(null);

  const handleAuthenticate = async () => {
    setAuthStatus("pending");
    setError(null);
    try {
      // Demo challenge and allowCredentials for testing only
      const publicKey = {
        // challenge: A random value from server to prevent replay attacks
        // In production, this should be generated by your backend for each auth attempt
        challenge: Uint8Array.from("randomChallenge123", (c) =>
          c.charCodeAt(0)
        ),
        // timeout: How long (in milliseconds) to wait for user interaction
        // After this time, the operation will fail
        timeout: 60000,
        // userVerification: Whether to require biometric/PIN verification
        // "required" = always prompt for biometric/PIN
        // "preferred" = prefer biometric/PIN but allow without
        // "discouraged" = don't require biometric/PIN
        userVerification: "required", // <-- This is the key!
      };
      const assertion = await navigator.credentials.get({ publicKey });
      if (assertion) {
        setAuthStatus("authenticated");
      } else {
        setAuthStatus("failed");
        console.log("Authentication failed:", assertion);
      }
    } catch (err) {
      setAuthStatus("failed");
      console.log("Authentication failed:", err);
      setError(err.message || "Authentication failed");
    }
  };

  const handleRegister = async () => {
    setAuthStatus("pending");
    setError(null);
    try {
      const publicKey = {
        // challenge: A random value from server to prevent replay attacks
        // In production, this should be generated by your backend for each registration
        challenge: Uint8Array.from("registerChallenge123", (c) =>
          c.charCodeAt(0)
        ),
        // rp: Relying Party - identifies your website/service
        // name: Human-readable name shown to user
        // id: Domain name (must match current domain for security)
        rp: {
          name: "Demo App",
          id: "codefolio.site", // Change from "localhost" to your actual domain
        },
        // user: Information about the user creating the credential
        // id: Unique user identifier (must be byte array)
        // name: Username/email (string)
        // displayName: Full name shown to user (string)
        user: {
          id: Uint8Array.from("demoUser", (c) => c.charCodeAt(0)),
          name: "demoUser",
          displayName: "Demo User",
        },
        // pubKeyCredParams: Supported cryptographic algorithms
        // alg: -7 = ES256 (ECDSA), -257 = RS256 (RSA)
        // Include both for maximum device compatibility
        pubKeyCredParams: [
          { type: "public-key", alg: -7 }, // ES256 (ECDSA w/ SHA-256)
          { type: "public-key", alg: -257 }, // RS256 (RSASSA-PKCS1-v1_5 w/ SHA-256)
        ],
        // timeout: How long (in milliseconds) to wait for user interaction
        timeout: 60000,
        // attestation: How much attestation data to include
        // "none" = minimal attestation (recommended for most apps)
        // "direct" = full attestation (for high-security apps)
        attestation: "none",
        // authenticatorSelection: Controls which authenticators can be used
        authenticatorSelection: {
          // userVerification: Whether to require biometric/PIN verification
          userVerification: "required",
          // residentKey: Whether the credential should be discoverable
          // "required" = must be discoverable (can find without knowing ID)
          // "preferred" = prefer discoverable
          // "discouraged" = don't make discoverable
          residentKey: "required",
          // authenticatorAttachment: Which type of authenticator to prefer
          // "platform" = built-in (fingerprint, Face ID, Windows Hello)
          // "cross-platform" = external (USB keys, QR codes)
          authenticatorAttachment: "platform", // Forces local platform authenticator
          // requireResidentKey: Forces the credential to be resident (discoverable)
          // This helps ensure local storage without cloud sync
          requireResidentKey: true,
        },
      };
      const credential = await navigator.credentials.create({ publicKey });
      if (credential) {
        console.log("Credential registered:", credential);
        setAuthStatus("registered");
        console.log(await credential.response.clientDataJSON);
        console.log(await credential.response.attestationObject);
      } else {
        console.log("Credential not registered");
        setAuthStatus("failed");
      }
    } catch (err) {
      setAuthStatus("failed");
      setError(err.message || "Registration failed");
    }
  };

  return (
    <div style={{ padding: 24 }}>
      <h2>WebAuthn Authentication Demo</h2>
      {authStatus === "authenticated" ? (
        <div style={{ color: "green" }}>
          <b>Authentication successful!</b>
          <div>Action: You are now authenticated and can proceed.</div>
        </div>
      ) : (
        <>
          <button
            onClick={handleRegister}
            disabled={authStatus === "pending"}
            style={{ marginRight: 8 }}
          >
            Register Passkey
          </button>
          <button
            onClick={handleAuthenticate}
            disabled={authStatus === "pending"}
          >
            {authStatus === "pending"
              ? "Authenticating..."
              : "Authenticate with WebAuthn"}
          </button>
          {authStatus === "failed" && (
            <div style={{ color: "red", marginTop: 12 }}>
              {authStatus === "registered"
                ? "Registration failed: "
                : "Authentication failed: "}
              {error}
            </div>
          )}
        </>
      )}
    </div>
  );
};

export default TestingLockScreenPin;
